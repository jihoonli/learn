一.const
	用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。
	所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值。
	
二.static
	1.在修饰局部变量的时候，static修饰的静态局部变量初始化只执行一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。 
	2.static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。 
	3.static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。

三.volatile
	volatile是一个类型修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。
	volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。
	
四.register
	（1）register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。

	（2）因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。

	（3）只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。

		在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。

	（4）局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c;

	（5）由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。

五.#define 和typedef
	1.执行时间不同
		关键字typedef在编译阶段有效，由于是在编译阶段，因此typedef有类型检查的功能。
		#define则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的				字符串替换，而不进行任何检查。
	2.功能有差异
		typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。
		#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
	3.作用域不同
		#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。
		而typedef有自己的作用域。
	4.对指针的操作
		二者修饰指针类型时，作用不同。
		
六.递归函数
	函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数
	
七.回调函数,什么时候用?
	回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
	回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

八.存储模型
	见APP 4G空间图
	
九.二级指针和二维数组
	
十.结构体和共用体
	共用体的成员共用一块内存区，结构体的成员有个自独立的内存区。所以，共用体的成员，对一个进行修改就会影响别的成员的值，而结构体则不会。
	结构体所占用的内存空间为其成员所需空间总和，而共用体所占用的空间只为其所需内存最大的成员的内存。
	
十一.sizeof和strlen区别，作用于数组的区别?
	1、定义不同
	sizeof是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。

	它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。
	具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：数组——编译时分配的数组空间大小；指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）。

	2、语法不同
	strlen是函数，要在运行时才能计算。参数必须是字符型指针。当数组名作为参数传入时，实际上数组就退化成指针了。
	它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。

十二.字对齐
	字对齐是指32位处理器以4字节（32位么）为一个单位取指令，如果是char型数据（定义为2b），但其实在存储中也是占4B。如果是两个连续的char 经过编译的优化可一起占4B
	
十三.什么是溢出？什么是泄露?什么是越界？
	内存溢出：系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出
	内存泄漏: 意思就是你用资源的时候为他开辟了一段空间，当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，但是内存泄漏次数多了就会导致内存溢出
	越界：数组下标越界

十四.位运算清零
	如 1010，
	全清零 1010& 0000 
	第二位清零 1010 &1101








