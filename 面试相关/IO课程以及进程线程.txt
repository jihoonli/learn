一.标准i/o和文件i/o的区别
	文件IO：调用系统函数，操作对象是文件描述符，无缓冲机制
	标准IO：使用标准C库，操作对象是流，有缓冲机制
	
二.缓存有几种类型
	buffers/cached/swap三类缓存
	buffers用来缓存metadata及pages，可以理解为系统缓存，例如，vi打开一个文件。

	cached用来给文件做缓存，可以理解为数据块缓存，例如，dd if=/dev/zero of=/tmp/test count=1 bs=1G 测试写入一个文件，就会被缓存到缓冲区中，当下一次再执行这个测试命令时，写入速度会明显很快。

	Swap是交换分区，即通常我们说的虚拟内存，是从硬盘中划分出的一个分区。当物理内存不够用的时候，内核就会释放缓存区（buffers/cache）里一些长时间不用的程序，然后将这些程序临时放到Swap中，也就是说如果物理内存和缓存区内存不够用的时候，才会用到Swap。

三.动态库与静态库区别
	静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库，因此体积较大。
	动态库在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要动态库存在，因此代码体积较小。
	
四.进程和程序区别
	进程是一个动态的概念，它是程序执行的过程，包括创建、调度和消亡。
	程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何的执行概念.

五.进程与线程的区别
	进程是资源分配的最小单位，线程是程序执行的最小单位。
	
	进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。

	线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。

	但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

六.僵尸进程和孤儿进程如何产生的
	孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

七.Fork与vfork
	使用fork，子进程与父进程的执行先后顺序不确定，使用vfork是子进程先运行，后运行父进程，
	Fork是子进程拷贝父进程空间，vfork则是子进程与父进程共享空间
	两者都是被调用一次，返回两次，子进程的返回值是0，而父进程的返回值则是子进程的进程ID

八.进程间通信有几种
	五种:
		无名管道、有名管道、消息队列、信号量(用于实现进程互斥与同步)、共享内存
		1.管道：速度慢，容量有限，只有父子进程能通讯    
		2.FIFO：任何进程间都能通讯，但速度慢    
		3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    
		4.信号量：不能传递复杂消息，只能用来同步    
		5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
		https://www.cnblogs.com/zgq0/p/8780893.html

九.无名管道和有名管道的区别
	无名管道:管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。
	
	有名管道：不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间）
	因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。

十.什么是竞态、同步与互斥
	linux系统编程中，经常会出现“竞态(race condition)”，即多进程的资源获取冲突或者访问时序问题。
	Linux提供的绝大多数系统调用函数保证函数调用过程是原子的(并非所有的系统调用均是原子的，见附录)，即单函数调用在返回或终止之前，该函数的操作是原子的，不受其他系统调用影响。
	但很多系统调用往往需要配合使用，由多个系统调用组成的调用组合，操作系统是无法保证原子性的！这意味着：2个以上系统调用组合在多进程环境下将出现“竞态”。如何避免竞态是linux系统编程的一个大问题。
	
	互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

	同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。
	少数情况是指可以允许多个访问者同时访问资源。
	
十一.什么是共享内存，以及应用场合？
	允许一组进程对其访问。
	共享内存是system vIPC中三种通信机制最快的一种，也是最简单的一种。对于进程来说，
	获得共享内存后，他对内存的使用和其他的内存是一样的。由一个进程对共享内存所进行的
	操作对其他进程来说都是立即可见的，
	
	使用共享内存进行进程间通信
	
	1、优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。

	2、缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。









